import sys
import os
import subprocess
import logging

try:
    from pathlib import Path
except ImportError:
    from pathlib2 import Path
from parameterized import parameterized

from .build_integ_base import BuildIntegBase


LOG = logging.getLogger(__name__)


class TestBuildCommand_PythonFunctions(BuildIntegBase):

    EXPECTED_FILES_GLOBAL_MANIFEST = set()
    EXPECTED_FILES_PROJECT_MANIFEST = {'__init__.py', 'main.py', 'numpy',
                                       # 'cryptography',
                                       "jinja2",
                                       'requirements.txt'}

    FUNCTION_LOGICAL_ID = "Function"

    @parameterized.expand([
        ("python2.7", False),
        ("python3.6", False),
        ("python3.7", False),
        ("python2.7", "use_container"),
        ("python3.6", "use_container"),
        ("python3.7", "use_container"),
    ])
    def test_with_default_requirements(self, runtime, use_container):

        # Don't run test on wrong Python versions
        py_version = self._get_python_version()
        if py_version != runtime:
            self.skipTest("Current Python version '{}' does not match Lambda runtime version '{}'".format(py_version,
                                                                                                          runtime))

        overrides = {"Runtime": runtime, "CodeUri": "Python", "Handler": "main.handler"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}", cmdlist)
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, self.FUNCTION_LOGICAL_ID,
                                    self.EXPECTED_FILES_PROJECT_MANIFEST)

        self._verify_resource_property(str(self.built_template),
                                       "OtherRelativePathResource",
                                       "BodyS3Location",
                                       os.path.relpath(
                                           os.path.normpath(os.path.join(str(self.test_data_path), "SomeRelativePath")),
                                           str(self.default_build_dir))
                                       )

        expected = {
            "pi": "3.14",
            "jinja": "Hello World"
        }
        self._verify_invoke_built_function(self.built_template,
                                           self.FUNCTION_LOGICAL_ID,
                                           self._make_parameter_override_arg(overrides),
                                           expected)
        self.verify_docker_container_cleanedup(runtime)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files):

        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)

    def _get_python_version(self):
        return "python{}.{}".format(sys.version_info.major, sys.version_info.minor)


class TestBuildCommand_ErrorCases(BuildIntegBase):

    def test_unsupported_runtime(self):
        overrides = {"Runtime": "unsupportedpython", "CodeUri": "NoThere"}
        cmdlist = self.get_command_list(parameter_overrides=overrides)

        LOG.info("Running Command: {}", cmdlist)
        process = subprocess.Popen(cmdlist, cwd=self.working_dir, stdout=subprocess.PIPE)
        process.wait()

        process_stdout = b"".join(process.stdout.readlines()).strip().decode('utf-8')
        self.assertEquals(1, process.returncode)

        self.assertIn("Build Failed", process_stdout)


class TestBuildCommand_NodeFunctions(BuildIntegBase):

    EXPECTED_FILES_GLOBAL_MANIFEST = set()
    EXPECTED_FILES_PROJECT_MANIFEST = {'node_modules', 'main.js'}
    EXPECTED_NODE_MODULES = {'minimal-request-promise'}

    FUNCTION_LOGICAL_ID = "Function"

    @parameterized.expand([
        ("nodejs6.10", False),
        ("nodejs8.10", False),
        ("nodejs10.x", False),
        ("nodejs6.10", "use_container"),
        ("nodejs8.10", "use_container"),
        ("nodejs10.x", "use_container")
    ])
    def test_with_default_package_json(self, runtime, use_container):
        overrides = {"Runtime": runtime, "CodeUri": "Node", "Handler": "ignored"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}", cmdlist)
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, self.FUNCTION_LOGICAL_ID,
                                    self.EXPECTED_FILES_PROJECT_MANIFEST, self.EXPECTED_NODE_MODULES)

        self._verify_resource_property(str(self.built_template),
                                       "OtherRelativePathResource",
                                       "BodyS3Location",
                                       os.path.relpath(
                                           os.path.normpath(os.path.join(str(self.test_data_path), "SomeRelativePath")),
                                           str(self.default_build_dir))
                                       )
        self.verify_docker_container_cleanedup(runtime)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files, expected_modules):

        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)

        all_modules = set(os.listdir(str(resource_artifact_dir.joinpath('node_modules'))))
        actual_files = all_modules.intersection(expected_modules)
        self.assertEquals(actual_files, expected_modules)


class TestBuildCommand_RubyFunctions(BuildIntegBase):

    EXPECTED_FILES_GLOBAL_MANIFEST = set()
    EXPECTED_FILES_PROJECT_MANIFEST = {'app.rb'}
    EXPECTED_RUBY_GEM = 'httparty'

    FUNCTION_LOGICAL_ID = "Function"

    @parameterized.expand([
        ("ruby2.5", False),
        ("ruby2.5", "use_container")
    ])
    def test_with_default_gemfile(self, runtime, use_container):
        overrides = {"Runtime": runtime, "CodeUri": "Ruby", "Handler": "ignored"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}".format(cmdlist))
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, self.FUNCTION_LOGICAL_ID,
                                    self.EXPECTED_FILES_PROJECT_MANIFEST, self.EXPECTED_RUBY_GEM)

        self._verify_resource_property(str(self.built_template),
                                       "OtherRelativePathResource",
                                       "BodyS3Location",
                                       os.path.relpath(
                                           os.path.normpath(os.path.join(str(self.test_data_path), "SomeRelativePath")),
                                           str(self.default_build_dir))
                                       )
        self.verify_docker_container_cleanedup(runtime)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files, expected_modules):

        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)

        ruby_version = None
        ruby_bundled_path = None

        # Walk through ruby version to get to the gem path
        for dirpath, dirname, _ in os.walk(str(resource_artifact_dir.joinpath('vendor', 'bundle', 'ruby'))):
            ruby_version = dirname
            ruby_bundled_path = Path(dirpath)
            break
        gem_path = ruby_bundled_path.joinpath(ruby_version[0], 'gems')

        self.assertTrue(any([True if self.EXPECTED_RUBY_GEM in gem else False for gem in os.listdir(str(gem_path))]))


class TestBuildCommand_Java(BuildIntegBase):

    EXPECTED_FILES_PROJECT_MANIFEST_GRADLE = {'aws', 'lib', "META-INF"}
    EXPECTED_FILES_PROJECT_MANIFEST_MAVEN = {'aws', 'lib'}
    EXPECTED_DEPENDENCIES = {'annotations-2.1.0.jar', "aws-lambda-java-core-1.1.0.jar"}

    FUNCTION_LOGICAL_ID = "Function"
    USING_GRADLE_PATH = os.path.join("Java", "gradle")
    USING_GRADLEW_PATH = os.path.join("Java", "gradlew")
    USING_GRADLE_KOTLIN_PATH = os.path.join("Java", "gradle-kotlin")
    USING_MAVEN_PATH = str(Path('Java', 'maven'))

    @parameterized.expand([
        ("java8", USING_GRADLE_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, False),
        ("java8", USING_GRADLEW_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, False),
        ("java8", USING_GRADLE_KOTLIN_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, False),
        ("java8", USING_MAVEN_PATH, EXPECTED_FILES_PROJECT_MANIFEST_MAVEN, False),
        ("java8", USING_GRADLE_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, "use_container"),
        ("java8", USING_GRADLEW_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, "use_container"),
        ("java8", USING_GRADLE_KOTLIN_PATH, EXPECTED_FILES_PROJECT_MANIFEST_GRADLE, "use_container"),
        ("java8", USING_MAVEN_PATH, EXPECTED_FILES_PROJECT_MANIFEST_MAVEN, "use_container")
    ])
    def test_with_building_java(self, runtime, code_path, expected_files, use_container):
        overrides = {"Runtime": runtime, "CodeUri": code_path, "Handler": "aws.example.Hello::myHandler"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}".format(cmdlist))
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, self.FUNCTION_LOGICAL_ID,
                                    expected_files, self.EXPECTED_DEPENDENCIES)

        self._verify_resource_property(str(self.built_template),
                                       "OtherRelativePathResource",
                                       "BodyS3Location",
                                       os.path.relpath(
                                           os.path.normpath(os.path.join(str(self.test_data_path), "SomeRelativePath")),
                                           str(self.default_build_dir))
                                       )

        expected = "Hello World"
        self._verify_invoke_built_function(self.built_template,
                                           self.FUNCTION_LOGICAL_ID,
                                           self._make_parameter_override_arg(overrides),
                                           expected)

        self.verify_docker_container_cleanedup(runtime)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files, expected_modules):

        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)

        lib_dir_contents = set(os.listdir(str(resource_artifact_dir.joinpath("lib"))))
        self.assertEquals(lib_dir_contents, expected_modules)


class TestBuildCommand_Dotnet_cli_package(BuildIntegBase):

    FUNCTION_LOGICAL_ID = "Function"
    EXPECTED_FILES_PROJECT_MANIFEST = {"Amazon.Lambda.APIGatewayEvents.dll", "HelloWorld.pdb",
                                       "Amazon.Lambda.Core.dll", "HelloWorld.runtimeconfig.json",
                                       "Amazon.Lambda.Serialization.Json.dll", "Newtonsoft.Json.dll",
                                       "HelloWorld.deps.json", "HelloWorld.dll"}

    @parameterized.expand([
        ("dotnetcore2.0", "Dotnetcore2.0", None),
        ("dotnetcore2.1", "Dotnetcore2.1", None),
        ("dotnetcore2.0", "Dotnetcore2.0", "debug"),
        ("dotnetcore2.1", "Dotnetcore2.1", "debug"),
    ])
    def test_with_dotnetcore(self, runtime, code_uri, mode):
        overrides = {"Runtime": runtime, "CodeUri": code_uri,
                     "Handler": "HelloWorld::HelloWorld.Function::FunctionHandler"}
        cmdlist = self.get_command_list(use_container=False,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}".format(cmdlist))
        LOG.info("Running with SAM_BUILD_MODE={}".format(mode))

        newenv = os.environ.copy()
        if mode:
            newenv["SAM_BUILD_MODE"] = mode

        process = subprocess.Popen(cmdlist, cwd=self.working_dir, env=newenv)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, self.FUNCTION_LOGICAL_ID,
                                    self.EXPECTED_FILES_PROJECT_MANIFEST)

        self._verify_resource_property(str(self.built_template),
                                       "OtherRelativePathResource",
                                       "BodyS3Location",
                                       os.path.relpath(
                                           os.path.normpath(os.path.join(str(self.test_data_path), "SomeRelativePath")),
                                           str(self.default_build_dir))
                                       )

        expected = "{'message': 'Hello World'}"
        self._verify_invoke_built_function(self.built_template,
                                           self.FUNCTION_LOGICAL_ID,
                                           self._make_parameter_override_arg(overrides),
                                           expected)

        self.verify_docker_container_cleanedup(runtime)

    @parameterized.expand([
        ("dotnetcore2.0", "Dotnetcore2.0"),
        ("dotnetcore2.1", "Dotnetcore2.1"),
    ])
    def test_must_fail_with_container(self, runtime, code_uri):
        use_container = True
        overrides = {"Runtime": runtime, "CodeUri": code_uri,
                     "Handler": "HelloWorld::HelloWorld.Function::FunctionHandler"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides)

        LOG.info("Running Command: {}".format(cmdlist))
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        # Must error out, because container builds are not supported
        self.assertEquals(process.returncode, 1)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files):

        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)


class TestBuildCommand_SingleFunctionBuilds(BuildIntegBase):
    template = "many-functions-template.yaml"

    EXPECTED_FILES_GLOBAL_MANIFEST = set()
    EXPECTED_FILES_PROJECT_MANIFEST = {'__init__.py', 'main.py', 'numpy',
                                       # 'cryptography',
                                       "jinja2",
                                       'requirements.txt'}

    def test_function_not_found(self):
        overrides = {"Runtime": 'python3.7', "CodeUri": "Python", "Handler": "main.handler"}
        cmdlist = self.get_command_list(parameter_overrides=overrides,
                                        function_identifier="FunctionNotInTemplate")

        process = subprocess.Popen(cmdlist, cwd=self.working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        self.assertEquals(process.returncode, 1)
        self.assertIn('FunctionNotInTemplate not found', str(stderr.decode('utf8')))

    @parameterized.expand([
        ("python3.7", False, "FunctionOne"),
        ("python3.7", "use_container", "FunctionOne"),
        ("python3.7", False, "FunctionTwo"),
        ("python3.7", "use_container", "FunctionTwo")
    ])
    def test_build_single_function(self, runtime, use_container, function_identifier):
        # Don't run test on wrong Python versions
        py_version = self._get_python_version()
        if py_version != runtime:
            self.skipTest("Current Python version '{}' does not match Lambda runtime version '{}'".format(py_version,
                                                                                                          runtime))

        overrides = {"Runtime": runtime, "CodeUri": "Python", "Handler": "main.handler"}
        cmdlist = self.get_command_list(use_container=use_container,
                                        parameter_overrides=overrides,
                                        function_identifier=function_identifier)

        LOG.info("Running Command: {}", cmdlist)
        process = subprocess.Popen(cmdlist, cwd=self.working_dir)
        process.wait()

        self._verify_built_artifact(self.default_build_dir, function_identifier,
                                    self.EXPECTED_FILES_PROJECT_MANIFEST)

        expected = {
            "pi": "3.14",
            "jinja": "Hello World"
        }
        self._verify_invoke_built_function(self.built_template,
                                           function_identifier,
                                           self._make_parameter_override_arg(overrides),
                                           expected)
        self.verify_docker_container_cleanedup(runtime)

    def _verify_built_artifact(self, build_dir, function_logical_id, expected_files):
        self.assertTrue(build_dir.exists(), "Build directory should be created")

        build_dir_files = os.listdir(str(build_dir))
        self.assertIn("template.yaml", build_dir_files)
        self.assertIn(function_logical_id, build_dir_files)

        template_path = build_dir.joinpath("template.yaml")
        resource_artifact_dir = build_dir.joinpath(function_logical_id)

        # Make sure the template has correct CodeUri for resource
        self._verify_resource_property(str(template_path),
                                       function_logical_id,
                                       "CodeUri",
                                       function_logical_id)

        all_artifacts = set(os.listdir(str(resource_artifact_dir)))
        actual_files = all_artifacts.intersection(expected_files)
        self.assertEquals(actual_files, expected_files)

    def _get_python_version(self):
        return "python{}.{}".format(sys.version_info.major, sys.version_info.minor)
