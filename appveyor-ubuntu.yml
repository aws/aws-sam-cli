version: 1.0.{build}
image:
  - Ubuntu2204

configuration:
  - BuildIntegTesting
  - BuildIntegTestingJavaPythonProvided
  - BuildIntegTestingArm64
  - BuildIntegTestingArm64Java
  - AllTerraformBuildTesting
  - PackageAndDeleteAndDeployIntegTesting
  - SyncIntegTesting
  - LocalInvokeIntegTesting
  - LocalStartIntegTesting
  # other Integration testing, Dev, regression and smoke testing
  - OtherAndEndToEndTesting

environment:
  # Common variables (inherited by all matrix jobs)
  PYTHON_HOME: "$HOME/venv3.9/bin"
  PYTHON_VERSION: "3.9"
  AWS_DEFAULT_REGION: us-east-1
  SAM_CLI_DEV: 1
  SAM_CLI_TELEMETRY: 0
  SAM_CLI_CONTAINER_CONNECTION_TIMEOUT: 60
  NODE_VERSION: "18.18.2"
  AWS_S3: "AWS_S3_TESTING"
  AWS_ECR: "AWS_ECR_TESTING"
  CARGO_LAMBDA_VERSION: "v0.17.1"
  PYTHON_ARCH: "64"
  NOSE_PARAMETERIZED_NO_WARN: 1
  APPVEYOR_CONSOLE_DISABLE_PTY: false
  APPVEYOR_DETAILED_SHELL_LOGGING: true

  # Matrix creates separate jobs for each runtime
  matrix:
    - CONTAINER_RUNTIME: docker
    # All common variables inherited, no additional Docker-specific variables needed

    - CONTAINER_RUNTIME: finch
      # All common variables inherited, no additional Finch-specific variables needed

install:
  # AppVeyor's apt-get cache might be outdated, and the package could potentially be 404.
  - sh: "sudo apt-get update --allow-releaseinfo-change"

  # install coretto 21
  - sh: wget -O - https://apt.corretto.aws/corretto.key | sudo gpg --dearmor -o /usr/share/keyrings/corretto-keyring.gpg
  - sh: echo "deb [signed-by=/usr/share/keyrings/corretto-keyring.gpg] https://apt.corretto.aws stable main" | sudo tee /etc/apt/sources.list.d/corretto.list
  - sh: sudo apt-get update; sudo apt-get install -y java-21-amazon-corretto-jdk
  - sh: JAVA_HOME=/usr/lib/jvm/java-21-amazon-corretto
  - sh: PATH=$JAVA_HOME/bin:$PATH
  - sh: java --version
  - sh: javac --version

  - sh: "gvm use go1.19"
  - sh: "echo $PATH"
  - sh: "ls /usr/"
  # install latest maven which is compatible with jdk17
  - sh: "sudo apt-get -y remove maven"
  - sh: "wget https://dlcdn.apache.org/maven/maven-3/3.9.11/binaries/apache-maven-3.9.11-bin.zip -P /tmp"
  - sh: "sudo unzip -d /opt/mvn /tmp/apache-maven-*.zip"
  - sh: "PATH=/opt/mvn/apache-maven-3.9.11/bin:$PATH"
  - sh: "mvn --version"

  # Finch Runtime Setup (Steps 1-7)
  - sh: |
      if [ "$CONTAINER_RUNTIME" = "finch" ]; then
        echo "=== Initializing Finch runtime ==="
        echo "Selected container runtime: $CONTAINER_RUNTIME"

        # Step 1: Stop Docker services for Finch
        echo "Stopping Docker services for Finch runtime..."
        sudo systemctl stop docker || echo "Warning: Docker stop failed, continuing..."
        sudo systemctl stop docker.socket || echo "Warning: Docker socket stop failed, continuing..."
        sudo systemctl disable docker || true
        sudo systemctl disable docker.socket || true
        echo "Docker services stopped successfully"

        # Step 2: Install Finch GPG key
        echo "Installing Finch GPG key..."
        GPG_SUCCESS=false
        for i in {1..3}; do
          if curl -fsSL https://artifact.runfinch.com/deb/GPG_KEY.pub | sudo gpg --dearmor -o /usr/share/keyrings/runfinch-finch-archive-keyring.gpg; then
            GPG_SUCCESS=true
            echo "Finch GPG key installed successfully"
            break
          else
            echo "GPG key installation attempt $i failed, retrying..."
            sleep 10
          fi
        done
        
        if [ "$GPG_SUCCESS" = "false" ]; then
          echo "FATAL: Failed to install Finch GPG key after 3 attempts"
          exit 1
        fi

        # Step 3: Add Finch repository and update apt
        echo "Adding Finch repository..."
        echo 'deb [signed-by=/usr/share/keyrings/runfinch-finch-archive-keyring.gpg arch=amd64] https://artifact.runfinch.com/deb noble main' | sudo tee /etc/apt/sources.list.d/runfinch-finch.list
        sudo apt update || { echo "FATAL: Failed to update apt after adding Finch repository"; exit 1; }
        echo "Finch repository added and apt updated successfully"

        # Step 4: Install Finch package
        echo "Installing Finch package..."
        if sudo apt install -y runfinch-finch; then
          echo "Finch package installed successfully"
        else
          echo "FATAL: Failed to install Finch package"
          exit 1
        fi

        # Step 5: Start Finch service
        echo "Enable and start Finch service..."
        sudo systemctl enable --now finch || { echo "FATAL: Failed to enable and start Finch service"; exit 1; }
        
        echo "Enable and start Finch Buildkit service..."
        sudo systemctl enable --now finch-buildkit || { echo "FATAL: Failed to enable and start Finch BuildKit service"; exit 1; }
        
        # Give Finch a moment to initialize
        sleep 3

        echo "Checking finch and finch-buildkit status..."
        sudo systemctl --no-pager status finch
        sudo systemctl --no-pager status finch-buildkit
        
        # Verify service is active
        if ! sudo systemctl is-active finch >/dev/null 2>&1; then
          echo "FATAL: Finch service is not active after start"
          sudo systemctl status finch
          exit 1
        fi
        echo "Finch service started and is active"

        # Step 6: Set Finch socket permissions for SAM CLI
        # Create finch group and add user for socket access
        if [ -S /var/run/finch.sock ]; then
          sudo chmod 666 /var/run/finch.sock
        else
          echo "âš  Finch socket not found at /var/run/finch.sock - this may cause SAM CLI failures"
          echo "Available sockets:"
          find /var/run /run -name "*.sock" -type s 2>/dev/null | head -10 || echo "No sockets found"
        fi

        # Step 7: Wait for Finch to be ready and display info
        echo "Waiting for Finch to be ready..."
        RUNTIME_READY=false
        for i in {1..12}; do
          if sudo finch info >/dev/null 2>&1; then
            RUNTIME_READY=true
            break
          fi
          echo "Finch not ready, waiting... (attempt $i/12)"
          sleep 5
        done

        if [ "$RUNTIME_READY" = "false" ]; then
          echo "FATAL: Finch failed to become ready within 60 seconds"
          echo "Attempting Finch service restart for proper BuildKit initialization..."
          sudo systemctl restart finch
          sleep 10
          
          if ! sudo finch info >/dev/null 2>&1; then
            echo "FATAL: Finch runtime initialization failed completely"
            exit 1
          fi
        fi
        echo "Finch is ready - displaying runtime information..."
        sudo finch info
        sudo finch version
        echo "Finch runtime successfully initialized"

        # Step 8: Setup BuildKit sockets for SAM CLI. Create symlink directories and set up sockets
        echo "Setting up BuildKit sockets for SAM CLI..."
        sudo mkdir -p /run/buildkit-finch /run/buildkit-default /run/buildkit
        sudo ln -sf /var/lib/finch/buildkit/buildkitd.sock /run/buildkit-finch/buildkitd.sock
        sudo ln -sf /var/lib/finch/buildkit/buildkitd.sock /run/buildkit-default/buildkitd.sock
        sudo ln -sf /var/lib/finch/buildkit/buildkitd.sock /run/buildkit/buildkitd.sock
        
        # Set group permissions for SAM CLI access
        sudo chmod 666 /var/lib/finch/buildkit/buildkitd.sock
        sudo chmod 666 /run/buildkit-*/buildkitd.sock

        # Set up cross platform build support
        sudo finch run --privileged --rm tonistiigi/binfmt:master --install all

        echo "  BuildKit sockets ready for SAM CLI"
        echo "=== Finch runtime initialization complete ==="
      fi

  # Docker Runtime Setup (Steps 1-3)
  - sh: |
      if [ "$CONTAINER_RUNTIME" = "docker" ]; then
        echo "=== Initializing Docker runtime ==="
        echo "Selected container runtime: $CONTAINER_RUNTIME"

        # Step 1: Initialize Docker runtime (no service changes needed)
        echo "Using Docker runtime - no service changes needed"

        # Step 2: Check Docker daemon status
        echo "Checking Docker daemon status..."
        if ! docker info >/dev/null 2>&1; then
          echo "Docker daemon not responding, attempting restart..."
          sudo systemctl restart docker || { echo "FATAL: Failed to restart Docker service"; exit 1; }
          echo "Docker service restarted successfully"
        else
          echo "Docker daemon is already running"
        fi

        # Step 3: Wait for Docker to be ready and display info
        echo "Waiting for Docker to be ready..."
        RUNTIME_READY=false
        for i in {1..12}; do
          if docker info >/dev/null 2>&1; then
            RUNTIME_READY=true
            break
          fi
          echo "Docker not ready, waiting... (attempt $i/12)"
          sleep 5
        done

        if [ "$RUNTIME_READY" = "false" ]; then
          echo "FATAL: Docker runtime initialization failed"
          exit 1
        fi

        echo "Docker is ready - displaying runtime information..."
        docker info
        docker version
        echo "Docker runtime successfully initialized"

        echo "=== Docker runtime initialization complete ==="
      fi

  - sh: "nvm install ${NODE_VERSION}"
  - sh: "npm install npm@10.2.3 -g"
  - sh: "npm -v"

  # Install latest gradle
  - sh: "sudo apt-get -y remove gradle"
  - sh: "wget https://services.gradle.org/distributions/gradle-9.0.0-bin.zip -P /tmp"
  - sh: "sudo unzip -d /opt/gradle /tmp/gradle-*.zip"
  - sh: "PATH=/opt/gradle/gradle-9.0.0/bin:$PATH"
  - sh: "gradle --version"

  # Install dotnet8 SDK
  - sh: "sudo apt-get update"
  - sh: "sudo apt-get install -y dotnet-sdk-8.0"

  # Install AWS CLI
  - sh: "virtualenv aws_cli"
  - sh: "./aws_cli/bin/python -m pip install awscli"
  - sh: "PATH=$(echo $PWD'/aws_cli/bin'):$PATH"

  - sh: "PATH=$PATH:$HOME/venv3.7/bin:$HOME/venv3.8/bin:$HOME/venv3.9/bin:$HOME/venv3.10/bin:$HOME/venv3.11/bin:$HOME/venv3.12/bin:$HOME/venv3.13/bin:$HOME/venv3.14/bin"

  # update ca-certificates which causes failures with newest golang library
  - sh: "sudo apt-get install --reinstall ca-certificates"

  # get testing env vars
  - sh: "sudo apt install -y jq"

  # install Rust
  - sh: "curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused -fsSL https://sh.rustup.rs | sh -s -- --default-toolchain none -y > /dev/null 2>&1"
  - sh: "source $HOME/.cargo/env"
  - sh: "rustup toolchain install stable --profile minimal --no-self-update"
  - sh: "rustup default stable"
  - sh: "rustup target add x86_64-unknown-linux-gnu --toolchain stable"
  - sh: "rustup target add aarch64-unknown-linux-gnu --toolchain stable"
  - sh: "pip install cargo-lambda==$CARGO_LAMBDA_VERSION"
  - sh: "rustc -V"
  - sh: "cargo -V"
  - sh: "cargo lambda -V"

  - sh: "python3.9 -m venv .venv_env_vars"
  - sh: ".venv_env_vars/bin/pip install boto3"
  - sh: "test_env_var=$(.venv_env_vars/bin/python tests/get_testing_resources.py)"
  - sh: |
      if [ $? -ne 0 ]; then
        echo "get_testing_resources failed. Failed to acquire credentials or test resources."
        false
      fi

  - sh: "export CI_ACCESS_ROLE_AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
  - sh: "export CI_ACCESS_ROLE_AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY"
  - sh: "export CI_ACCESS_ROLE_AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN"

  - sh: 'export AWS_ACCESS_KEY_ID=$(echo "$test_env_var" | jq -j ".accessKeyID")'
  - sh: 'export AWS_SECRET_ACCESS_KEY=$(echo "$test_env_var" | jq -j ".secretAccessKey")'
  - sh: 'export AWS_SESSION_TOKEN=$(echo "$test_env_var" | jq -j ".sessionToken")'
  - sh: 'export TASK_TOKEN=$(echo "$test_env_var" | jq -j ".taskToken")'
  - sh: 'export AWS_S3_TESTING=$(echo "$test_env_var" | jq -j ".TestBucketName")'
  - sh: 'export AWS_ECR_TESTING=$(echo "$test_env_var" | jq -j ".TestECRURI")'
  - sh: 'export AWS_KMS_KEY=$(echo "$test_env_var" | jq -j ".TestKMSKeyArn")'
  - sh: 'export AWS_SIGNING_PROFILE_NAME=$(echo "$test_env_var" | jq -j ".TestSigningProfileName")'
  - sh: 'export AWS_SIGNING_PROFILE_VERSION_ARN=$(echo "$test_env_var" | jq -j ".TestSigningProfileARN")'

  # Runtime-aware Docker Hub authentication with fail-fast
  - sh: |
      if [[ -n $BY_CANARY ]] && [[ -n $DOCKER_USER ]] && [[ -n $DOCKER_PASS ]]; then
        if [ "$CONTAINER_RUNTIME" = "finch" ]; then
          echo "Logging in Docker Hub with Finch"
          echo $DOCKER_PASS | sudo finch login --username $DOCKER_USER --password-stdin registry-1.docker.io || { echo "FATAL: Finch Docker Hub login failed"; exit 1; }
          echo $DOCKER_PASS | sudo finch login --username $DOCKER_USER --password-stdin || { echo "FATAL: Finch Docker Hub login failed"; exit 1; }
        else
          echo "Logging in Docker Hub with Docker"
          echo $DOCKER_PASS | docker login --username $DOCKER_USER --password-stdin registry-1.docker.io || { echo "FATAL: Docker Hub login failed"; exit 1; }
          echo $DOCKER_PASS | docker login --username $DOCKER_USER --password-stdin || { echo "FATAL: Docker Hub login failed"; exit 1; }
        fi
      fi
  # Runtime-aware QEMU setup for ARM64 emulation with fail-fast
  - sh: |
      echo "Setting up QEMU for ARM64 emulation with $CONTAINER_RUNTIME"
      if [ "$CONTAINER_RUNTIME" = "finch" ]; then
        sudo finch run --rm --privileged multiarch/qemu-user-static --reset -p yes || { echo "FATAL: Finch QEMU setup failed"; exit 1; }
      else
        docker run --rm --privileged multiarch/qemu-user-static --reset -p yes || { echo "FATAL: Docker QEMU setup failed"; exit 1; }
      fi
      echo "QEMU setup completed successfully"

  # Runtime-aware Public ECR authentication with fail-fast
  - sh: |
      if [[ -n $BY_CANARY ]]; then
        if [ "$CONTAINER_RUNTIME" = "finch" ]; then
          echo "Logging in Public ECR with Finch"
          aws ecr-public get-login-password --region us-east-1 | sudo finch login --username AWS --password-stdin public.ecr.aws || { echo "FATAL: Finch Public ECR login failed"; exit 1; }
        else
          echo "Logging in Public ECR with Docker"
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws || { echo "FATAL: Docker Public ECR login failed"; exit 1; }
        fi
        echo "Public ECR authentication completed successfully"
      fi

  - sh: "source ${HOME}/venv${PYTHON_VERSION}/bin/activate"

build_script:
  # Quick runtime validation before build
  - sh: |
      echo "Validating $CONTAINER_RUNTIME runtime..."
      if [ "$CONTAINER_RUNTIME" = "finch" ]; then
        sudo finch info >/dev/null 2>&1 || { echo "FATAL: Finch not ready"; exit 1; }
        echo "  Finch runtime ready"
      else
        docker info >/dev/null 2>&1 || { echo "FATAL: Docker not ready"; exit 1; }
        echo "  Docker runtime ready"
      fi
  - 'python -c "import sys; print(sys.executable)"'
  - "make init"

# Final clean up no matter success or failure
on_finish:
  # Rename test reports to include runtime suffix and upload as artifacts
  - sh: |
      for file in $(find "$APPVEYOR_BUILD_FOLDER" -type f -name 'TEST_REPORT-*.json'); do
        new_name=$(echo "$file" | sed "s/\.json$/-${CONTAINER_RUNTIME}.json/")
        mv "$file" "$new_name"
        appveyor PushArtifact "$new_name"
      done

  # Generate runtime-specific diagnostic logs
  - sh: |
      echo "=== ${CONTAINER_RUNTIME^^} Runtime Diagnostics ===" > "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      echo "Job ID: $APPVEYOR_JOB_ID" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      echo "Build ID: $APPVEYOR_BUILD_ID" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      echo "Timestamp: $(date -u)" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"

      if [ "$CONTAINER_RUNTIME" = "finch" ]; then
        echo "=== Finch Info ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        sudo finch info >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get finch info" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Finch Version ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        sudo finch version >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get finch version" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Finch Service Status ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        sudo systemctl status finch >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get finch service status" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Finch Socket Info ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        ls -la /var/run/finch.sock >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get finch socket info" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== BuildKit Sockets ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        ls -la /run/buildkit*/buildkitd.sock >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "No BuildKit sockets found" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Environment Variables ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "CONTAINER_RUNTIME=$CONTAINER_RUNTIME" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      else
        echo "=== Docker Info ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        docker info >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get docker info" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Docker Version ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        docker version >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get docker version" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        echo "" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        
        echo "=== Docker Service Status ===" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
        sudo systemctl status docker >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log" 2>&1 || echo "Failed to get docker service status" >> "runtime-diagnostics-${CONTAINER_RUNTIME}.log"
      fi

      appveyor PushArtifact "runtime-diagnostics-${CONTAINER_RUNTIME}.log"

  # Cleanup container resources (best effort)
  - sh: |
      echo "=== Cleaning up container resources for $CONTAINER_RUNTIME ==="
      if [ "$CONTAINER_RUNTIME" = "finch" ]; then
        # Clean up Finch containers and images (best effort)
        sudo finch container prune -f 2>/dev/null || echo "Finch container cleanup skipped"
        sudo finch image prune -f 2>/dev/null || echo "Finch image cleanup skipped"
        echo "Finch cleanup completed"
      else
        # Clean up Docker containers and images (best effort)
        docker container prune -f 2>/dev/null || echo "Docker container cleanup skipped"
        docker image prune -f 2>/dev/null || echo "Docker image cleanup skipped"
        echo "Docker cleanup completed"
      fi

  # Upload runtime-specific test reports to S3
  - sh: >
      AWS_ACCESS_KEY_ID=$TEST_REPORT_S3_BUCKET_ACCESS_KEY_ID 
      AWS_SECRET_ACCESS_KEY=$TEST_REPORT_S3_BUCKET_SECRET_ACCESS_KEY 
      AWS_SESSION_TOKEN=$TEST_REPORT_S3_BUCKET_SESSION_TOKEN 
      aws s3 cp "$APPVEYOR_BUILD_FOLDER" "s3://$TEST_REPORT_S3_BUCKET_NAME/appveyor/$APPVEYOR_PROJECT_SLUG/$APPVEYOR_BUILD_ID/$APPVEYOR_JOB_ID/" --recursive --exclude "*" --include "TEST_REPORT-*-${CONTAINER_RUNTIME}.json" --include "runtime-diagnostics-${CONTAINER_RUNTIME}.log" --region us-west-2

  # notify task success
  - sh: "export AWS_ACCESS_KEY_ID=$CI_ACCESS_ROLE_AWS_ACCESS_KEY_ID"
  - sh: "export AWS_SECRET_ACCESS_KEY=$CI_ACCESS_ROLE_AWS_SECRET_ACCESS_KEY"
  - sh: "export AWS_SESSION_TOKEN=$CI_ACCESS_ROLE_AWS_SESSION_TOKEN"

  # When we update to AWS CLI v2, we need to add the `--cli-binary-format raw-in-base64-out` option to pass the payload as a JSON string
  - sh: >
      aws lambda invoke --function-name "$ACCOUNT_RESET_LAMBDA_ARN" --payload "{\"taskToken\": \"$TASK_TOKEN\", \"output\": \"{}\"}" ./lambda-output.txt --region us-west-2
  - sh: "cat ./lambda-output.txt"

for:
  # Integ testing build
  - matrix:
      only:
        - configuration: BuildIntegTesting

    test_script:
      # Install Ruby for Ruby build tests
      - sh: "rbenv install 3.3.7"
      - sh: "rbenv install 3.4.2"
      - sh: "rbenv install 3.2.7"
      - sh: "rbenv global 3.3.7"
      - sh: "ruby --version"
      - sh: "pytest -vv -n 2 --reruns 3 tests/integration/buildcmd -m 'not java and not python and not provided' --ignore=tests/integration/buildcmd/test_build_cmd_arm64.py --ignore=tests/integration/buildcmd/test_build_terraform_applications.py --ignore=tests/integration/buildcmd/test_build_terraform_applications_other_cases.py --json-report --json-report-file=TEST_REPORT-integration-buildcmd.json"

  - matrix:
      only:
        - configuration: BuildIntegTestingJavaPythonProvided

    test_script:
      - sh: "pytest -vv -n 2 --reruns 3 tests/integration/buildcmd -m 'java or python or provided' --ignore=tests/integration/buildcmd/test_build_cmd_arm64.py --ignore=tests/integration/buildcmd/test_build_terraform_applications.py --ignore=tests/integration/buildcmd/test_build_terraform_applications_other_cases.py --json-report --json-report-file=TEST_REPORT-integration-buildcmd-java-python-provided.json"

  # Integ testing build arm64 functions
  - matrix:
      only:
        - configuration: BuildIntegTestingArm64

    test_script:
      # Install Ruby for Ruby ARM64 build tests
      - sh: "rbenv install 3.3.7"
      - sh: "rbenv install 3.4.2"
      - sh: "rbenv install 3.2.7"
      - sh: "rbenv global 3.3.7"
      - sh: "ruby --version"
      - sh: "pytest -vv --reruns 3 tests/integration/buildcmd/test_build_cmd_arm64.py -m 'not java' --json-report --json-report-file=TEST_REPORT-integration-buildcmd-arm64.json"

  - matrix:
      only:
        - configuration: BuildIntegTestingArm64Java

    test_script:
      - sh: "pytest -vv --reruns 3 tests/integration/buildcmd/test_build_cmd_arm64.py -m 'java' --json-report --json-report-file=TEST_REPORT-integration-buildcmd-arm64-java.json"

  # Integ testing Terraform build
  - matrix:
      only:
        - configuration: AllTerraformBuildTesting

    test_script:
      # install Terraform
      - sh: "sudo apt update --allow-releaseinfo-change"
      - sh: "TER_VER=`curl -s https://api.github.com/repos/hashicorp/terraform/releases/latest | grep tag_name | cut -d: -f2 | tr -d \\\"\\,\\v | awk '{$1=$1};1'`"
      - sh: "wget https://releases.hashicorp.com/terraform/${TER_VER}/terraform_${TER_VER}_linux_amd64.zip -P /tmp"
      - sh: "sudo unzip -d /opt/terraform /tmp/terraform_${TER_VER}_linux_amd64.zip"
      - sh: "sudo mv /opt/terraform/terraform /usr/local/bin/"
      - sh: "terraform -version"

      - sh: "pytest -vv -n 4 --reruns 4 tests/integration/buildcmd/test_build_terraform_applications.py tests/integration/buildcmd/test_build_terraform_applications_other_cases.py --json-report --json-report-file=TEST_REPORT-integration-terraform.json"

  # Integ testing package & delete
  - matrix:
      only:
        - configuration: PackageAndDeleteAndDeployIntegTesting

    test_script:
      - sh: "pytest -vv tests/integration/package tests/integration/delete tests/integration/deploy --dist=loadgroup -n 4 --reruns 4 --json-report --json-report-file=TEST_REPORT-integration-package-delete-deploy.json"

  # Integ testing sync
  - matrix:
      only:
        - configuration: SyncIntegTesting

    test_script:
      # Install Ruby for Ruby sync tests
      - sh: "rbenv install 3.3.7"
      - sh: "rbenv install 3.4.2"
      - sh: "rbenv install 3.2.7"
      - sh: "rbenv global 3.3.7"
      - sh: "ruby --version"
      - sh: "pytest -vv tests/integration/sync -n 3 --reruns 3 --dist loadscope --json-report --json-report-file=TEST_REPORT-integration-sync.json"

  # Integ testing local
  - matrix:
      only:
        - configuration: LocalInvokeIntegTesting

    test_script:
      # install Terraform
      - sh: "sudo apt update --allow-releaseinfo-change"
      - sh: "TER_VER=`curl -s https://api.github.com/repos/hashicorp/terraform/releases/latest | grep tag_name | cut -d: -f2 | tr -d \\\"\\,\\v | awk '{$1=$1};1'`"
      - sh: "wget https://releases.hashicorp.com/terraform/${TER_VER}/terraform_${TER_VER}_linux_amd64.zip -P /tmp"
      - sh: "sudo unzip -d /opt/terraform /tmp/terraform_${TER_VER}_linux_amd64.zip"
      - sh: "sudo mv /opt/terraform/terraform /usr/local/bin/"
      - sh: "terraform -version"

      - sh: "pytest -vv --reruns 3 tests/integration/local/invoke tests/integration/local/generate_event --json-report --json-report-file=TEST_REPORT-integration-local-invoke.json"

  # Integ testing local
  - matrix:
      only:
        - configuration: LocalStartIntegTesting

    test_script:
      # install Terraform
      - sh: "sudo apt update --allow-releaseinfo-change"
      - sh: "TER_VER=`curl -s https://api.github.com/repos/hashicorp/terraform/releases/latest | grep tag_name | cut -d: -f2 | tr -d \\\"\\,\\v | awk '{$1=$1};1'`"
      - sh: "wget https://releases.hashicorp.com/terraform/${TER_VER}/terraform_${TER_VER}_linux_amd64.zip -P /tmp"
      - sh: "sudo unzip -d /opt/terraform /tmp/terraform_${TER_VER}_linux_amd64.zip"
      - sh: "sudo mv /opt/terraform/terraform /usr/local/bin/"
      - sh: "terraform -version"

      - sh: "pytest -vv --reruns 3 tests/integration/local/start_api tests/integration/local/start_lambda --json-report --json-report-file=TEST_REPORT-integration-local-start.json"

  # Other testing
  - matrix:
      only:
        - configuration: OtherAndEndToEndTesting

    test_script:
      # Install Ruby for Ruby validation and other tests
      - sh: "rbenv install 3.3.7"
      - sh: "rbenv install 3.4.2"
      - sh: "rbenv install 3.2.7"
      - sh: "rbenv global 3.3.7"
      - sh: "ruby --version"
      - sh: "pytest -vv -n 4 --reruns 4 --dist loadgroup tests/integration tests/end_to_end --ignore=tests/integration/buildcmd --ignore=tests/integration/delete --ignore=tests/integration/deploy --ignore=tests/integration/package --ignore=tests/integration/sync --ignore=tests/integration/local --json-report --json-report-file=TEST_REPORT-integration-others.json"
      - sh: "pytest -vv --reruns 3 tests/regression --json-report --json-report-file=TEST_REPORT-regression.json"
